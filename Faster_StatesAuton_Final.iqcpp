{"mode":"Text","textContent":"#pragma region VEXcode Generated Robot Configuration\n// Make sure all required headers are included.\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdbool.h>\n#include <math.h>\n#include <string.h>\n\n\n#include \"vex.h\"\n\nusing namespace vex;\n\n// Brain should be defined by default\nbrain Brain;\n\n\n// START IQ MACROS\n#define waitUntil(condition)                                                   \\\n  do {                                                                         \\\n    wait(5, msec);                                                             \\\n  } while (!(condition))\n\n#define repeat(iterations)                                                     \\\n  for (int iterator = 0; iterator < iterations; iterator++)\n// END IQ MACROS\n\n\n// Robot configuration code.\ninertial BrainInertial = inertial();\nmotor LeftMotor = motor(PORT1, false);\nmotor RightMotor = motor(PORT7, true);\ngyro Gyro4 = gyro(PORT4);\ntouchled TouchLED11 = touchled(PORT11);\nmotor IntakeMotorA = motor(PORT9, true);\nmotor IntakeMotorB = motor(PORT3, false);\nmotor_group Intake = motor_group(IntakeMotorA, IntakeMotorB);\n\nmotor LiftMotorA = motor(PORT2, false);\nmotor LiftMotorB = motor(PORT8, true);\nmotor_group Lift = motor_group(LiftMotorA, LiftMotorB);\n\nbumper Bumper10 = bumper(PORT10);\ncolorsensor Color12 = colorsensor(PORT12);\ncolorsensor Color6 = colorsensor(PORT6);\n\n#pragma endregion VEXcode Generated Robot Configuration\n\n//Author: Ishaan Agarwal  Date: 3/6/2024\n/*Changes Made From Previous Version (SCAuton_AA):\n    -Increased distance while collecting second line\n    -Decreased velocity in antijam\n    -Added a second lineup prior to green dump\n    -decreased time by 4 seconds now at 56 seconds\n*/\n\n// Include the IQ Library\n#include \"vex.h\"\n  \n// Allows for easier use of the VEX Library\nusing namespace vex;\n\n// User defined function\nvoid initialSetup();\n// User defined function\n\nvoid drive(double distance, double heading, double velocity, double kP, double timeout);\n// User defined function\nvoid turn(double heading, bool errorCorrection);\n\nint Brain_precision = 0, Console_precision = 0;\n\nfloat myVariable, startTime, error, output, programRunTime, NO_TIMEOUT;\n\nbool direction, isIntakeOn = false;\n\nevent LEDblink = event();\nevent message1 = event();\n\n// initialSetup\nvoid initialSetup() {\n  LEDblink.broadcast();\n  Gyro4.calibrate(calSlow);\n  Gyro4.setHeading(0.0, degrees);\n  Gyro4.setRotation(0.0, degrees);\n  Intake.setStopping(coast);\n  Intake.setVelocity(95.0, percent);\n  Lift.setVelocity(100.0, percent);\n  Lift.setMaxTorque(30.0, percent);\n  Intake.setMaxTorque(100.0, percent);\n  Lift.spin(reverse);\n  waitUntil(Bumper10.pressing());\n  wait(0.25, seconds);\n  Lift.stop();\n  Lift.spinFor(forward, 100.0, degrees, true);\n  Lift.setPosition(0.0, degrees);\n  LeftMotor.setStopping(brake);\n  RightMotor.setStopping(brake);\n  Lift.setStopping(hold);\n  myVariable = 0.0;\n  NO_TIMEOUT = 100000.0;\n}\n\n// drive function\nvoid drive(double distance, double heading, double velocity, double kP, double timeout=60) {\n  LeftMotor.setPosition(0.0, degrees);\n  RightMotor.setPosition(0.0, degrees);\n  LeftMotor.setTimeout(1.0, seconds);\n  RightMotor.setTimeout(1.0, seconds);\n  startTime = Brain.Timer.value();\n  if (velocity > 0.0) {\n    while ((LeftMotor.position(degrees) < distance && startTime + timeout > Brain.Timer.value())) {\n      error = heading - Gyro4.rotation();\n      output = error * kP;\n      LeftMotor.setVelocity((velocity - output), percent);\n      RightMotor.setVelocity((velocity + output), percent);\n      LeftMotor.spin(forward);\n      RightMotor.spin(forward);\n    wait(20, msec);\n    }\n  }\n  else {\n    while ((distance < LeftMotor.position(degrees) && startTime + timeout > Brain.Timer.value())) {\n      error = heading - Gyro4.rotation();\n      output = error * kP;\n      LeftMotor.setVelocity((velocity - output), percent);\n      RightMotor.setVelocity((velocity + output), percent);\n      LeftMotor.spin(forward);\n      RightMotor.spin(forward);\n    wait(20, msec);\n    }\n  }\n  LeftMotor.stop();\n  RightMotor.stop();\n}\n\n// turn function\nvoid turn(double heading, bool errorCorrection=true) {\n  float turnKp = 100;\n\n  if (heading > Gyro4.rotation()) {\n    while ((heading - 5 > Gyro4.rotation())) {\n    \n    //limits for the turn function\n    float turnError = heading - Gyro4.rotation();\n    float turnVelocity = turnError * turnKp / 180.0;\n    if (turnVelocity < 10) turnVelocity = 10;\n    if (turnError < 90 && turnError > 30) turnVelocity = 40;\n    \n    LeftMotor.setVelocity(turnVelocity, percent);\n    RightMotor.setVelocity(turnVelocity, percent);\n    LeftMotor.spin(reverse);\n    RightMotor.spin(forward);\n    wait(20, msec);\n\n    }\n  }\n  else {\n    while ((Gyro4.rotation() > heading + 5)) {\n\n      float turnError = Gyro4.rotation() - heading;\n      float turnVelocity = turnError * turnKp / 180.0;      \n      if (turnVelocity < 10) turnVelocity = 10;\n\n      LeftMotor.setVelocity(turnVelocity, percent);\n      RightMotor.setVelocity(turnVelocity, percent);\n      LeftMotor.spin(forward);\n      RightMotor.spin(reverse);\n      wait(20, msec);\n    }\n  }\n\n  LeftMotor.stop();\n  RightMotor.stop();\n\n  if (errorCorrection){\n    wait(100, msec);\n    turn(heading, false);\n  }\n}\n\n// \"when started\" hat block\nint whenStarted1() {\n  initialSetup();\n  while (true) {\n    if (isIntakeOn == true) {\n      if (Intake.velocity(percent) < 5) {\n        wait(0.5, seconds);\n\n        if(Intake.velocity(percent) < 5) {\n          Brain.Screen.print(\"jammed\");\n          Brain.Screen.newLine();\n          Intake.setVelocity(50, percent);\n          Intake.spin(reverse);\n          wait(0.75, sec);\n          Intake.setVelocity(95, percent);\n          Intake.spin(forward);\n          wait(0.2, seconds);\n          Brain.Screen.print(\"unjammed\");\n        }\n      } \n    }\n    wait(20, msec);\n  }\n  return 0;\n}\n\n// \"when I receive LEDblink\" hat block\nvoid onevent_LEDblink_0() {\n  if (Brain.Battery.capacity(percent) > 95.0) {\n    TouchLED11.setColor(blue_green);\n    repeat(12) {\n      TouchLED11.setColor(colorType::none);\n      wait(0.25, seconds);\n      TouchLED11.setColor(blue_green);\n      wait(20, msec);\n    }\n  }\n  else {\n    TouchLED11.setColor(red);\n    Brain.playSound(wrongWaySlow);\n    repeat(12) {\n      TouchLED11.setColor(colorType::none);\n      wait(0.25, seconds);\n      TouchLED11.setColor(red);\n      wait(20, msec);\n    }\n  }\n}\n\n// Used to find the format string for printing numbers with the\n// desired number of decimal places\nconst char* printToBrain_numberFormat() {\n  // look at the current precision setting to find the format string\n  switch(Brain_precision){\n    case 0:  return \"%.0f\"; // 0 decimal places (1)\n    case 1:  return \"%.1f\"; // 1 decimal place  (0.1)\n    case 2:  return \"%.2f\"; // 2 decimal places (0.01)\n    case 3:  return \"%.3f\"; // 3 decimal places (0.001)\n    default: return \"%f\"; // use the print system default for everthing else\n  }\n}\n\n// \"when TouchLED11 pressed\" hat block\nvoid onevent_TouchLED11_pressed_0() {\n  Gyro4.setHeading(0.0, degrees);\n  Gyro4.setRotation(0.0, degrees);\n\n  Intake.spin(forward);\n  //collect first line of greens\n  drive(450, 0, 60, 1);\n  isIntakeOn = true;\n  drive(-50, 0, 60, 1);\n  wait(0.1, seconds);\n  \n  //collect flower\n  turn(-90);\n  drive(100, -90, 40, 1);\n  wait(0.25, seconds);\n  drive(50, -90, 40, 1);\n  wait(0.4, seconds);\n  drive(100, -90, 60, 1);\n  wait(0.1, seconds);\n\n  //collect from middle\n  //turn heading used to be 65\n  turn(68);\n  //distance was 800\n  drive(825, 68, 60, 1);\n  turn(105);\n  drive(600, 105, 40, 1);\n\n  //collect line\n  turn(180);\n  //distance was 400\n  drive(375, 180, 60, 1);\n\n  //collect flower\n  turn(45);\n  //all drive headings were 45\n  drive(125, 45, 40, 1);\n  wait(0.25, seconds);\n  drive(100, 45, 40, 1);\n  wait(0.4, seconds);\n  drive(100, 45, 60, 0);\n  \n  //dump purples\n  turn(-15);\n  LeftMotor.setVelocity(60, percent);\n  RightMotor.setVelocity(80, percent);\n  LeftMotor.spin(reverse);\n  RightMotor.spin(reverse);\n  wait(0.7, seconds);\n  Lift.spin(reverse);\n  //velocity threshold changed from -5 to -25\n  while (LeftMotor.velocity(percent) < -25 && RightMotor.velocity(percent) < -25) {\n    //LeftMotor.spin(reverse);\n    //RightMotor.spin(reverse);\n    wait(20, msec);\n  }\n  Lift.spin(reverse);\n  wait(0.25, seconds);\n  Lift.stop();\n  drive(50, 0, 80, 1);\n  drive(-50, 0, -100, 1);\n  wait(0.25, seconds);\n  Lift.spinToPosition(0, degrees, false);\n  //Lift.stop();\n  //wait(0.5,seconds);\n  //Lift.spinToPosition(0, degrees, false);\n  LeftMotor.stop();\n  RightMotor.stop();\n\n  //collect flowers in the back\n  //distance was 700; 720\n  drive(710, -20, 80, 2);\n  drive(400, -45, 80, 1.5);\n  wait(0.1, seconds);\n\n  drive(100, -90, 80, 1);\n  wait(0.25, seconds);\n  drive(100, -90, 40, 1);\n  wait(0.5, seconds);\n  drive(100, -90, 60, 1);\n  wait(0.1, seconds);\n  \n  drive(300, -90, 60, 1);\n  wait(0.25, seconds);\n  drive(100, -90, 60, 1);\n  wait(0.5, seconds);\n  //velocity was 60\n  drive(200, -90, 40, 1);\n  wait(0.1, seconds);\n\n  //collect from middle\n  //distance was -465 velociy was -80\n  drive(-475, -90, -60, 1);\n  drive(400, -180, 60, 1);\n  drive(300, -180, 80, 1);\n  //wait(0.2, seconds);\n  drive(250, -180, 40, 1, 2);\n  //distance was -650, heading was -175\n  drive(-600, -180, -60, 1);\n\n  //dump purples\n  turn(-135);\n  drive(-600, -90, -80, 1);\n  LeftMotor.setVelocity(80, percent);\n  RightMotor.setVelocity(100, percent);\n  LeftMotor.spin(reverse);\n  RightMotor.spin(reverse);\n  wait(0.5, seconds);\n\n  Lift.spin(reverse);\n  //velocity threshold changed from -5 to -25\n  while (LeftMotor.velocity(percent) < -25 && RightMotor.velocity(percent) < -25) {\n    LeftMotor.spin(reverse);\n    RightMotor.spin(reverse);\n  }\n  //Lift.spin(reverse);\n  wait(0.25, seconds);\n  Lift.stop();\n  drive(50, -90, 80, 1);\n  drive(-50, -90, -100, 1);\n  wait(0.25, seconds);\n  Lift.spinToPosition(0, degrees, false);\n  LeftMotor.stop();\n  RightMotor.stop();\n\n  //dump greens\n  drive(400, -110, 60, 1);\n  drive(400, -180, 60, 1);\n  turn(-315);\n  //kP was 0.75\n  drive(-1000, -280, -80, 1);\n  //heading was -270\n  drive(-400, -265, -60, 1, 1);\n  drive(20, -270, 60, 1);\n  turn(-340);\n  LeftMotor.setVelocity(100, percent);\n  RightMotor.setVelocity(80, percent);\n  LeftMotor.spin(reverse);\n  RightMotor.spin(reverse);\n  wait(0.5, seconds);\n  while (LeftMotor.velocity(percent) < -5 && RightMotor.velocity(percent) < -5) {\n    LeftMotor.spin(reverse);\n    RightMotor.spin(reverse);\n  }\n\n  LeftMotor.stop();\n  RightMotor.stop();\n\n  LeftMotor.setVelocity(100, percent);\n  RightMotor.setVelocity(100, percent);\n\n  LeftMotor.spin(forward);\n  RightMotor.spin(forward);\n\n  wait(0.5, seconds);\n\n  LeftMotor.stop();\n  RightMotor.stop();\n\n  //turn(-350);\n\n  LeftMotor.setVelocity(100, percent);\n  RightMotor.setVelocity(60, percent);\n  LeftMotor.spin(reverse);\n  RightMotor.spin(reverse);\n  while (LeftMotor.velocity(percent) < -5 && RightMotor.velocity(percent) < -5) {\n    LeftMotor.spin(reverse);\n    RightMotor.spin(reverse);\n  }\n  Lift.spinToPosition(540, degrees);\n  wait(0.25, seconds);\n  Lift.spinToPosition(840, degrees);\n  wait(0.75, seconds);\n  Lift.spinToPosition(0, degrees, false);\n\n  isIntakeOn = false;\n\n  //park\n  RightMotor.setVelocity(100, percent);\n  LeftMotor.stop();\n  RightMotor.stop();\n  LeftMotor.spin(forward);\n  RightMotor.spin(forward);\n  wait(3,seconds);\n  Intake.stop();\n  wait(2, seconds);\n  LeftMotor.stop();\n  RightMotor.stop();\n}\n\n\nint main() {\n  // register event handlers\n  LEDblink(onevent_LEDblink_0);\n  TouchLED11.pressed(onevent_TouchLED11_pressed_0);\n\n  wait(15, msec);\n  whenStarted1();\n}","textLanguage":"cpp","rconfig":[{"port":[1],"name":"LeftMotor","customName":true,"deviceType":"Motor","deviceClass":"motor","setting":{"reversed":"false","fwd":"forward","rev":"reverse"},"triportSourcePort":22},{"port":[7],"name":"RightMotor","customName":true,"deviceType":"Motor","deviceClass":"motor","setting":{"reversed":"true","fwd":"forward","rev":"reverse"},"triportSourcePort":22},{"port":[4],"name":"Gyro4","customName":false,"deviceType":"Gyro","deviceClass":"gyro","setting":{},"triportSourcePort":22},{"port":[11],"name":"TouchLED11","customName":false,"deviceType":"TouchLED","deviceClass":"touchled","setting":{},"triportSourcePort":22},{"port":[9,3],"name":"Intake","customName":true,"deviceType":"MotorGroup","deviceClass":"motor_group","setting":{"fwd":"forward","rev":"reverse","motor_a_reversed":"true","motor_b_reversed":"false"},"triportSourcePort":22},{"port":[2,8],"name":"Lift","customName":true,"deviceType":"MotorGroup","deviceClass":"motor_group","setting":{"fwd":"forward","rev":"reverse","motor_a_reversed":"false","motor_b_reversed":"true"},"triportSourcePort":22},{"port":[10],"name":"Bumper10","customName":false,"deviceType":"Bumper","deviceClass":"bumper","setting":{},"triportSourcePort":22},{"port":[12],"name":"Color12","customName":false,"deviceType":"Color","deviceClass":"colorsensor","setting":{},"triportSourcePort":22},{"port":[6],"name":"Color6","customName":false,"deviceType":"Color","deviceClass":"colorsensor","setting":{},"triportSourcePort":22}],"slot":3,"platform":"IQ","sdkVersion":"20230818.11.00.00","appVersion":"3.0.4","minVersion":"3.0.0","fileFormat":"1.2.0","icon":"","targetBrainGen":"Second","v5SoundsEnabled":false,"target":"Physical"}